From: Kurtis Rader <krader@skepticism.us>
Date: Tue, 17 Sep 2019 19:24:45 -0700
Subject: Initialize the jobs table earlier

While investigating a security issue it came to light that the jobs
table isn't initialized early enough. Prior to this change command
substitution might happen before it is initialized. Which leads to
dereferencing a NULL pointer.

(cherry picked from commit 25f73f42250e9d690c40e1f0323c29d6d88956c5)
---
 src/cmd/ksh93/sh/init.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/src/cmd/ksh93/sh/init.c b/src/cmd/ksh93/sh/init.c
index f3b8e96..a61fe1a 100644
--- a/src/cmd/ksh93/sh/init.c
+++ b/src/cmd/ksh93/sh/init.c
@@ -1145,6 +1145,11 @@ Shell_t *sh_init(int argc, char *argv[], Shinit_f userinit) {
     // Initialize signal handling.
     sh_siginit(shp);
     stkinstall(NULL, nospace);
+    // Initialize the jobs table. This needs to be done very early because, at least at this time,
+    // importing vars from the environment can result in performing command substitution.  Which
+    // means external commands (jobs) might be run. Even if that dubious, undocumented, behavior is
+    // ever changed we should still init the jobs table as early as possible.
+    job_clear(shp);
     // Set up memory for name-value pairs.
     shp->init_context = nv_init(shp);
     // Read the environment.
@@ -1188,8 +1193,6 @@ Shell_t *sh_init(int argc, char *argv[], Shinit_f userinit) {
 #endif
     nv_putval(IFSNOD, (char *)e_sptbnl, NV_RDONLY);
     shp->st.tmout = READ_TIMEOUT;
-    // Initialize jobs table.
-    job_clear(shp);
     sh_onoption(shp, SH_MULTILINE);
     if (argc > 0) {
         int dolv_index = -1;
